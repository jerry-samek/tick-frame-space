#!/usr/bin/env python3
"""
Fragmented Electron Cloud Implementation for Experiment 56 Phase 4 V3

Based on Doc 070_00: "Fragmented Electron Cloud as an Emergent Attractor"
and Doc 070_01: "Collision-Driven Stabilization of Fragmented Electron Patterns"

The electron is not a single particle but an ensemble of micro-patterns
distributed within the gamma-well of the proton.
"""

import numpy as np
from dataclasses import dataclass, field
from typing import List, Tuple, Optional
import math
import random


# ============================================================================
# Pattern Type (for compatibility with binding detection)
# ============================================================================

class Pattern:
    """Pattern representing a particle fragment."""

    def __init__(self, pattern_type: str, energy: float, mass: float):
        self.pattern_type = pattern_type
        self.energy = energy
        self.mass = mass


# ============================================================================
# Electron Fragment (Doc 070_00 §1: Fragmented Entity)
# ============================================================================

@dataclass
class ElectronFragment:
    """
    Single micro-pattern within the electron cloud.

    From Doc 070_00:
    "Each fragment possesses its own local trajectory, energy, and phase,
    and is influenced by the central gamma-well generated by the proton."

    Attributes:
        fragment_id: Unique identifier
        position: Position relative to proton (x, y)
        velocity: Velocity vector (vx, vy)
        energy: Fragment energy (share of total electron energy)
        mass: Fragment mass (share of total electron mass)
        last_collision_tick: Tick of most recent collision
        collision_count: Total number of collisions
    """

    fragment_id: str
    position: np.ndarray
    velocity: np.ndarray
    energy: float
    mass: float

    # Collision tracking
    last_collision_tick: int = 0
    collision_count: int = 0

    # History (for analysis)
    position_history: List[np.ndarray] = field(default_factory=list)
    velocity_history: List[np.ndarray] = field(default_factory=list)

    def __post_init__(self):
        """Ensure arrays are numpy arrays."""
        if not isinstance(self.position, np.ndarray):
            self.position = np.array(self.position, dtype=float)
        if not isinstance(self.velocity, np.ndarray):
            self.velocity = np.array(self.velocity, dtype=float)

    @property
    def speed(self) -> float:
        """Current speed (magnitude of velocity)."""
        return float(np.linalg.norm(self.velocity))

    @property
    def kinetic_energy(self) -> float:
        """Kinetic energy: KE = (1/2) × m × v²"""
        return 0.5 * self.mass * (self.speed ** 2)

    @property
    def distance_from_origin(self) -> float:
        """Distance from origin (proton position)."""
        return float(np.linalg.norm(self.position))

    def as_pattern(self) -> Pattern:
        """Convert to Pattern object for field computation."""
        return Pattern(
            pattern_type="ELECTRON_FRAGMENT",
            energy=self.energy,
            mass=self.mass
        )

    def update_position(self, dt: float = 1.0):
        """Update position based on current velocity."""
        self.position += self.velocity * dt

    def apply_acceleration(self, acceleration: np.ndarray, dt: float = 1.0):
        """Apply acceleration to velocity."""
        self.velocity += acceleration * dt

    def record_history(self):
        """Record current state to history."""
        self.position_history.append(np.copy(self.position))
        self.velocity_history.append(np.copy(self.velocity))


# ============================================================================
# Fragmented Electron Cloud (Doc 070_00: Emergent Attractor)
# ============================================================================

class FragmentedElectronCloud:
    """
    Ensemble of electron fragments forming a coherent attractor.

    From Doc 070_00:
    "The electron is not a point-like particle but a distributed ensemble
    of micro-entities—tick-localized fragments that collectively form
    a coherent attractor."

    From Doc 070_01:
    "These fragments interact, collide, and redistribute energy, leading
    to the emergence of stable orbital levels without requiring quantum
    uncertainty as a fundamental axiom."
    """

    def __init__(self, cloud_id: str = "electron_cloud"):
        """Initialize empty cloud."""
        self.cloud_id = cloud_id
        self.fragments: List[ElectronFragment] = []

        # Collective properties (measured, not prescribed)
        self.center_of_mass = np.array([0.0, 0.0])
        self.total_mass = 0.0
        self.total_energy = 0.0
        self.total_kinetic_energy = 0.0
        self.cloud_radius_rms = 0.0
        self.cloud_radius_mean = 0.0
        self.cloud_radius_std = 0.0

        # Angular momentum
        self.angular_momentum = 0.0
        self.angular_momentum_per_fragment = 0.0

        # Statistics
        self.total_collisions = 0
        self.collision_rate = 0.0  # Collisions per tick
        self.energy_distribution = np.array([])
        self.radial_density_profile = np.array([])

    def add_fragment(self, fragment: ElectronFragment):
        """Add a fragment to the cloud."""
        self.fragments.append(fragment)
        self.total_mass += fragment.mass
        self.total_energy += fragment.energy

    def initialize_fragments(
        self,
        n_fragments: int,
        r_mean: float = 2.0,
        r_std: float = 0.5,
        v_mean: float = 0.1,
        v_std: float = 0.02,
        total_mass: float = 0.001,
        total_energy: float = 5.0
    ):
        """
        Initialize N electron fragments with random positions and velocities.

        From Doc 070_01 §1:
        "Each fragment has its own local velocity, its own micro-energy,
        its own trajectory within the gamma-well."

        Args:
            n_fragments: Number of fragments to create
            r_mean: Mean initial radius (Gaussian distribution)
            r_std: Standard deviation of radius
            v_mean: Mean velocity magnitude
            v_std: Standard deviation of velocity
            total_mass: Total electron mass (distributed equally)
            total_energy: Total electron energy (distributed equally)
        """
        self.fragments = []
        fragment_mass = total_mass / n_fragments
        fragment_energy = total_energy / n_fragments

        for i in range(n_fragments):
            # Random position (2D Gaussian around origin)
            # Use polar coordinates for spherical distribution
            theta = random.uniform(0, 2 * math.pi)
            r = random.gauss(r_mean, r_std)
            r = max(0.1, r)  # Ensure r > 0

            position = np.array([
                r * math.cos(theta),
                r * math.sin(theta)
            ])

            # Random velocity (magnitude from Gaussian, direction random)
            v_mag = random.gauss(v_mean, v_std)
            v_mag = max(0.0, v_mag)  # Ensure v >= 0
            v_angle = random.uniform(0, 2 * math.pi)

            velocity = np.array([
                v_mag * math.cos(v_angle),
                v_mag * math.sin(v_angle)
            ])

            fragment = ElectronFragment(
                fragment_id=f"efrag_{i}",
                position=position,
                velocity=velocity,
                energy=fragment_energy,
                mass=fragment_mass
            )

            self.add_fragment(fragment)

        # Update statistics
        self.update_statistics()

        print(f"Initialized {n_fragments} electron fragments:")
        print(f"  Mean radius: {self.cloud_radius_mean:.4f}")
        print(f"  RMS radius: {self.cloud_radius_rms:.4f}")
        print(f"  Total mass: {self.total_mass:.6f}")
        print(f"  Total energy: {self.total_energy:.4f}")

    def update_statistics(self):
        """
        Compute collective properties from fragment states.

        These are MEASURED properties that emerge from dynamics,
        not prescribed parameters.
        """
        if len(self.fragments) == 0:
            return

        # Center of mass
        total_mass = sum(f.mass for f in self.fragments)
        com_x = sum(f.mass * f.position[0] for f in self.fragments) / total_mass
        com_y = sum(f.mass * f.position[1] for f in self.fragments) / total_mass
        self.center_of_mass = np.array([com_x, com_y])

        # Cloud radius statistics
        distances = [f.distance_from_origin for f in self.fragments]
        self.cloud_radius_mean = float(np.mean(distances))
        self.cloud_radius_std = float(np.std(distances))
        self.cloud_radius_rms = float(np.sqrt(np.mean([d**2 for d in distances])))

        # Total energies
        self.total_mass = total_mass
        self.total_energy = sum(f.energy for f in self.fragments)
        self.total_kinetic_energy = sum(f.kinetic_energy for f in self.fragments)

        # Angular momentum (total L = Σ r × p)
        total_L = 0.0
        for f in self.fragments:
            r = f.position
            p = f.mass * f.velocity
            # In 2D: L = r_x × p_y - r_y × p_x (z-component only)
            L_z = r[0] * p[1] - r[1] * p[0]
            total_L += L_z

        self.angular_momentum = total_L
        self.angular_momentum_per_fragment = total_L / len(self.fragments)

        # Energy distribution
        energies = [f.energy for f in self.fragments]
        self.energy_distribution = np.array(energies)

        # Collision statistics
        total_collisions = sum(f.collision_count for f in self.fragments)
        self.total_collisions = total_collisions

    def compute_radial_density_profile(
        self,
        n_bins: int = 50,
        max_radius: float = 20.0
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        Compute radial density profile ρ(r).

        Returns:
            (radii, densities) where densities[i] is count in bin i
        """
        distances = [f.distance_from_origin for f in self.fragments]

        # Create histogram
        counts, bin_edges = np.histogram(
            distances,
            bins=n_bins,
            range=(0, max_radius)
        )

        # Bin centers
        radii = (bin_edges[:-1] + bin_edges[1:]) / 2

        # Normalize by bin volume (2π × r × dr in 2D)
        dr = bin_edges[1] - bin_edges[0]
        volumes = 2 * np.pi * radii * dr
        densities = counts / (volumes + 1e-10)  # Avoid division by zero

        self.radial_density_profile = densities

        return radii, densities

    def get_statistics_dict(self) -> dict:
        """Get all statistics as dictionary for logging."""
        return {
            'n_fragments': len(self.fragments),
            'center_of_mass': self.center_of_mass.tolist(),
            'cloud_radius_mean': float(self.cloud_radius_mean),
            'cloud_radius_rms': float(self.cloud_radius_rms),
            'cloud_radius_std': float(self.cloud_radius_std),
            'total_mass': float(self.total_mass),
            'total_energy': float(self.total_energy),
            'total_kinetic_energy': float(self.total_kinetic_energy),
            'angular_momentum': float(self.angular_momentum),
            'angular_momentum_per_fragment': float(self.angular_momentum_per_fragment),
            'total_collisions': int(self.total_collisions),
            'collision_rate': float(self.collision_rate),
        }

    def check_stability(
        self,
        max_escape_radius: float = 20.0
    ) -> Tuple[bool, int, List[str]]:
        """
        Check cloud stability.

        Returns:
            (is_stable, n_escaped, escaped_ids)
        """
        escaped = []
        for f in self.fragments:
            if f.distance_from_origin > max_escape_radius:
                escaped.append(f.fragment_id)

        is_stable = len(escaped) == 0
        return is_stable, len(escaped), escaped


# ============================================================================
# Fragment Initialization Helpers
# ============================================================================

def create_thermal_velocity_distribution(
    n_fragments: int,
    temperature: float = 0.1,
    mass: float = 0.001
) -> List[np.ndarray]:
    """
    Create Maxwell-Boltzmann velocity distribution for fragments.

    Args:
        n_fragments: Number of fragments
        temperature: Temperature parameter (in natural units)
        mass: Fragment mass

    Returns:
        List of velocity vectors
    """
    # Maxwell-Boltzmann: P(v) ∝ v × exp(-m×v²/(2×k×T))
    # In 2D, use Rayleigh distribution for speed

    velocities = []
    sigma = math.sqrt(temperature / mass)  # Standard deviation

    for _ in range(n_fragments):
        # Speed from Rayleigh distribution
        v_mag = np.random.rayleigh(sigma)

        # Random direction
        theta = random.uniform(0, 2 * math.pi)

        velocity = np.array([
            v_mag * math.cos(theta),
            v_mag * math.sin(theta)
        ])

        velocities.append(velocity)

    return velocities


def create_ring_distribution(
    n_fragments: int,
    radius: float = 2.0,
    width: float = 0.5
) -> List[np.ndarray]:
    """
    Create fragments in a ring (for testing orbital modes).

    Args:
        n_fragments: Number of fragments
        radius: Ring radius
        width: Ring width (radial uncertainty)

    Returns:
        List of positions
    """
    positions = []

    for i in range(n_fragments):
        # Equally spaced in angle
        theta = 2 * math.pi * i / n_fragments

        # Radius with small perturbation
        r = radius + random.gauss(0, width)
        r = max(0.1, r)

        position = np.array([
            r * math.cos(theta),
            r * math.sin(theta)
        ])

        positions.append(position)

    return positions


# ============================================================================
# Testing
# ============================================================================

if __name__ == "__main__":
    print("Testing FragmentedElectronCloud...")

    # Create cloud
    cloud = FragmentedElectronCloud(cloud_id="test_cloud")

    # Initialize 50 fragments
    cloud.initialize_fragments(
        n_fragments=50,
        r_mean=2.0,
        r_std=0.5,
        v_mean=0.1,
        v_std=0.02,
        total_mass=0.001,
        total_energy=5.0
    )

    # Check statistics
    stats = cloud.get_statistics_dict()
    print("\nCloud statistics:")
    for key, value in stats.items():
        if isinstance(value, float):
            print(f"  {key}: {value:.6f}")
        else:
            print(f"  {key}: {value}")

    # Check stability
    is_stable, n_escaped, escaped_ids = cloud.check_stability(max_escape_radius=10.0)
    print(f"\nStability check: {is_stable}")
    print(f"  Escaped fragments: {n_escaped}")

    # Compute radial density
    radii, densities = cloud.compute_radial_density_profile(n_bins=20, max_radius=10.0)
    print(f"\nRadial density profile computed ({len(radii)} bins)")
    print(f"  Peak density at r={radii[np.argmax(densities)]:.2f}")

    print("\n[OK] FragmentedElectronCloud test passed!")
