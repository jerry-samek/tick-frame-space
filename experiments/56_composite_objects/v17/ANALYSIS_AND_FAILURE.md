# V17 Analysis: Canvas Ontology - Insufficient and Ontologically Incomplete

**Status:** FAILED - Does not meet RAW-083 requirements  
**Date:** 2026-02-04  
**Analysis of:** V17 Canvas/Renderer Model  
**Against:** RAW-083 (Unified Imprint Principle)

---

## Executive Summary

V17 implements a **single-entity canvas model** with sparse gamma storage. While technically functional and memory-efficient, it **fundamentally violates the Unified Imprint Principle** described in RAW-083 and cannot be extended to model **composite objects** without ontological contradiction.

**Verdict:** V17 must be abandoned as a foundation for composite physics. A new architecture (V18) is required.

---

## What V17 Does Well

### 1. Sparse Storage ✓
- Uses dict-based storage instead of dense 3D arrays
- Memory scales O(painted_cells) instead of O(grid³)
- Enables longer simulations (10k+ ticks feasible)

### 2. Gradient-Based Navigation ✓
- Renderers follow gamma gradients toward higher concentration
- Skip probability = |gradient| * SKIP_SENSITIVITY produces time dilation
- Emergent clustering around paint accumulations

### 3. Deterministic Physics ✓
- Each tick is deterministic given seed
- No probabilistic skip/act - pure gradient-driven behavior
- Reproducible patterns

---

## What V17 Gets Wrong: Ontological Violations

### Problem 1: No Unified Imprint for Composites

**RAW-083 Requirement:**
> A composite object must have a **single imprint** in the gamma field.

**V17 Reality:**
- Each renderer is an **independent entity**
- Each renderer has **its own imprint** (accumulates paint around it)
- Each renderer has **its own position**, **its own time_dilation_factor**, **its own last_paint_pos**
- There is **no mechanism** to bind multiple renderers into one composite with one unified imprint

**Code Evidence:**
```python
# evolution.py - line 71-73
def create_renderer(self) -> Renderer:
    renderer = Renderer(entity_id=self.tick_count, seed=self.config.random_seed)
    renderer.set_position(self.origin)
    self.renderers.append(renderer)  # Independent renderer added to collection
```

Each new renderer is a **separate process** with separate state tracking.

### Problem 2: No Unified Wake Model

**RAW-083 Requirement:**
> A composite object must have a **single wake** - one gamma-wake producing one gravitational behavior.

**V17 Reality:**
- Canvas accumulates paint from all renderers
- There is **no distinction** between:
  - Paint from different renderers
  - Paint from internal structure vs external paint
  - Wake generated by one entity vs wake from another
- **Wake interference is implicit and unmodeled**

**Result:** No way to represent gravitational cohesion of a composite vs sub-entities.

### Problem 3: No Unified Tick Budget

**RAW-083 Requirement:**
> A composite object has **one tick-budget** - one energy pool shared across all internal structure.

**V17 Reality:**
- Each renderer independently:
  - Receives ENERGY_PER_TICK (1.0)
  - Pays gamma_cost individually
  - Tracks own skip_accumulator independently
- **No shared energy pool**
- **No resource constraint forcing coherence**

**Code Evidence:**
```python
# renderer.py - line 71-76
self.total_skips: int = 0
self.total_acts: int = 0
self.skip_accumulator: int = 0
# Each renderer tracks independently - no coupling
```

### Problem 4: Multi-Imprint Composites Fail (Predicted by RAW-083)

**RAW-083 Section 4: Why Multi-Imprint Composites Fail**

V17 would exhibit all predicted failures if attempted to model composites:

#### 4.1 Different Drift Rates
- Each renderer has independent last_paint_pos
- Each experiences gradient independently
- They would **drift apart under expansion** (if expansion were modeled)

#### 4.2 Different Tick Budgets
- Each renderer has independent energy allocation
- Some would exhaust skip_accumulator sooner
- The "composite" would **disintegrate**

#### 4.3 Wake Interference
- Multiple renderers produce overlapping paint
- No mechanism to distinguish internal structure from collision
- **No stable geometry can emerge**

#### 4.4 No Shared Resistance
- Each renderer resists expansion independently
- No unified structural cohesion mechanism
- Composite **cannot maintain shape**

### Problem 5: Renderer "Statefulness" Contradicts Design Philosophy

V17 claims:
> Renderer is stateless - it only sees current canvas

**Reality:**
```python
# renderer.py - line 24-29
class Renderer:
    def __init__(self, entity_id: int, seed: int):
        self.entity_id = entity_id
        self.last_paint_pos: Pos3D = (0, 0, 0)
        self.total_skips: int = 0
        self.total_acts: int = 0
```

Renderer **maintains 4 pieces of persistent state** across ticks:
- entity_id (identity)
- last_paint_pos (position memory)
- total_skips (history)
- total_acts (history)

This is **not stateless** - it's a **stateful temporal process**.

### Problem 6: Canvas as "Only State" is Incomplete

V17 claims:
> Canvas IS the state. No external memory - the accumulated paint is the only state.

**Reality:**
- Canvas stores paint only
- Canvas **does not store** renderer positions
- Canvas **does not store** individual time_dilation factors
- Canvas **does not encode** which paint came from which renderer
- The actual state is **split between canvas and renderer collection**

---

## Why V17 Cannot Be Extended to Composites

### Attempt 1: "Just Add More Renderers to a Composite"

If we try to model H₂ molecule as:
```
Composite_H2:
  - Renderer_proton1 at (0, 0, 0)
  - Renderer_proton2 at (1, 0, 0)
```

**Immediately fails:**
- Proton1 and Proton2 each have independent last_paint_pos
- Each follows gradients independently
- They drift apart under expansion (predicted by RAW-083 §4.1)
- No shared tick-budget keeps them together
- Wake from proton1 interferes with proton2's gradient (destabilization)
- The bond has **no representation** in the model

### Attempt 2: "Add Binding Energy to Renderers"

If we add "bond_strength" to hold them together:

**Violates RAW-083 entirely:**
- Now the composite has multiple imprints (proton1 + proton2 + bond?)
- Bond is not a real entity but artificial constraint
- This is exactly what RAW-083 forbids

### Attempt 3: "Combine Two Renderers into One"

If we try to represent H₂ as single renderer with "internal state = [proton1, proton2]":

**This is RAW-083 correct, but V17 doesn't support it:**
- Renderer class has no internal_state array
- No mechanism to encode multi-particle structure
- No way to transition internal states between ticks
- The canvas still has no way to distinguish internal structure from external accumulation

---

## What Would Be Needed to Fix V17

To make V17 conform to RAW-083, we would need:

1. **Replace Renderer with CompositeProcess**
   - Single imprint per process
   - Single wake per process
   - Single tick-budget per process
   - Internal_state array (not sub-entities)

2. **Extend Canvas to track wake**
   - Wake as ∂gamma/∂t (derivative field)
   - Or wake as historical gamma diffs
   - Needed for accurate gravity calculation

3. **Unified gradient field per process**
   - Not per-renderer gradient
   - Process reads its own gradient, not individual sub-particle gradients

4. **Energy distribution mechanism**
   - Shared tick-budget allocated to internal state transitions
   - Not independent energy per sub-entity

5. **Internal state machine**
   - Each tick: read shared imprint + wake → internal state transition
   - Paint unified imprint based on internal state
   - Not independent paint decisions per sub-entity

**This would be a complete rewrite, not an extension of V17.**

---

## Conclusion: V17 is Dead Code

V17 successfully demonstrates:
- ✓ Sparse canvas storage
- ✓ Gradient-based movement in single-entity case
- ✓ Memory-efficient simulation for long runs

But it **cannot** model composites, **violates** RAW-083, and **must be replaced** by a proper unified imprint architecture.

### Next Steps: V18

A new implementation is required:

1. **CompositeProcess as primary entity**
   - Not Renderer
   - Replaces multi-entity pattern entirely

2. **Wake field integrated into Canvas**
   - Proper gravity model
   - Not just paint accumulation

3. **Internal state machine architecture**
   - Encodes structure without sub-entities
   - Enables molecular/biological models

4. **Unified tick-budget and energy allocation**
   - Global resource constraint enforcing coherence
   - Not independent per-entity

See: `V18_DESIGN.md` for the new architecture.

---

## References

- **RAW-083:** Composite Processes and the Unified Imprint Principle
- **RAW-049:** Temporal Ontology
- **RAW-081:** Photon as Degenerate Process
- **RAW-082:** Gamma-Wake Gravity Principle

